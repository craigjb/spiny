/*                           /$$                                             **
**                          |__/                                             **
**        /$$$$$$$  /$$$$$$  /$$ /$$$$$$$  /$$   /$$                         **
**       /$$_____/ /$$__  $$| $$| $$__  $$| $$  | $$                         **
**      |  $$$$$$ | $$  \ $$| $$| $$  \ $$| $$  | $$   (c) Craig J Bishop    **
**       \____  $$| $$  | $$| $$| $$  | $$| $$  | $$   All rights reserved   **
**       /$$$$$$$/| $$$$$$$/| $$| $$  | $$|  $$$$$$$                         **
**      |_______/ | $$____/ |__/|__/  |__/ \____  $$   MIT License           **
**                | $$                     /$$  | $$                         **
**                | $$                    |  $$$$$$/                         **
**                |__/                     \______/                          **
**                                                                           **
** Permission is hereby granted, free of charge, to any person obtaining a   **
** copy of this software and associated documentation files (the             **
** "Software"), to deal in the Software without restriction, including       **
** without limitation the rights to use, copy, modify, merge, publish,       **
** distribute, sublicense, and/or sell copies of the Software, and to permit **
** persons to whom the Software is furnished to do so, subject to the        **
** following conditions:                                                     **
**                                                                           **
** The above copyright notice and this permission notice shall be included   **
** in all copies or substantial portions of the Software.                    **
**                                                                           **
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS   **
** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                **
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN **
** NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,  **
** DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR     **
** OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE **
** USE OR OTHER DEALINGS IN THE SOFTWARE.                                    */

package spiny.dram

import spinal.core._
import spinal.lib._
import spinal.lib.bus.wishbone._

/**
 * LiteDRAM native user port interface
 */
case class NativePort(
  addressWidth: Int,
  dataWidth: Int
) extends Bundle with IMasterSlave {

  // Command channel
  val cmd = Stream(new Bundle {
    val we = Bool()
    val addr = UInt(addressWidth bits)
  })

  // Write data channel
  val write = Stream(new Bundle {
    val we = Bits(dataWidth / 8 bits)
    val data = Bits(dataWidth bits)
  })

  // Read data channel
  val read = Stream(Bits(dataWidth bits))

  override def asMaster(): Unit = {
    master(cmd)
    master(write)
    slave(read)
  }

  /**
   * Set signal names to match LiteDRAM's generated Verilog
   */
  def setLiteDramNames(portName: String): this.type = {
    cmd.valid.setName(s"user_port_${portName}_cmd_valid")
    cmd.ready.setName(s"user_port_${portName}_cmd_ready")
    cmd.payload.we.setName(s"user_port_${portName}_cmd_we")
    cmd.payload.addr.setName(s"user_port_${portName}_cmd_addr")
    write.valid.setName(s"user_port_${portName}_wdata_valid")
    write.ready.setName(s"user_port_${portName}_wdata_ready")
    write.payload.we.setName(s"user_port_${portName}_wdata_we")
    write.payload.data.setName(s"user_port_${portName}_wdata_data")
    read.valid.setName(s"user_port_${portName}_rdata_valid")
    read.ready.setName(s"user_port_${portName}_rdata_ready")
    read.payload.setName(s"user_port_${portName}_rdata_data")
    this
  }
}

/**
 * LiteDRAM controller BlackBox
 *
 * Wraps the Verilog generated by LiteDRAM with a SpinalHDL interface.
 * The Verilog is generated by the FuseSoC litedram generator.
 *
 * @param config LiteDRAM configuration parameters
 * @param sim LiteDRAM sim mode with internal DRAM model
 */
case class LiteDram(
  config: LiteDramConfig,
  sim: Boolean = false
) extends BlackBox {

  // Set the module name to match generated Verilog
  setDefinitionName(config.name)

  val io = new Bundle {
    // Input clock and reset (for internal PLL)
    val clk = in Bool() setName("clk")
    val rst = (!sim) generate {
      in Bool() setName("rst")
    }

    // User clock domain outputs
    val userClk = out Bool() setName("user_clk")
    val userRst = out Bool() setName("user_rst")

    // Status outputs
    val pllLocked = (!sim) generate {
      out Bool() setName("pll_locked")
    }
    val initDone = out Bool() setName("init_done")
    val initError = out Bool() setName("init_error")

    // Wishbone control bus
    val wbCtrl = slave(Wishbone(WishboneConfig(
      addressWidth = 30,
      dataWidth = 32,
      selWidth = 4,
      useSTALL = false,
      useLOCK = false,
      useERR = true,
      useRTY = false,
      useBTE = true,
      useCTI = true
    )))
    wbCtrl.CYC.setName("wb_ctrl_cyc")
    wbCtrl.STB.setName("wb_ctrl_stb")
    wbCtrl.ACK.setName("wb_ctrl_ack")
    wbCtrl.WE.setName("wb_ctrl_we")
    wbCtrl.ADR.setName("wb_ctrl_adr")
    wbCtrl.DAT_MISO.setName("wb_ctrl_dat_r")
    wbCtrl.DAT_MOSI.setName("wb_ctrl_dat_w")
    wbCtrl.SEL.setName("wb_ctrl_sel")
    wbCtrl.ERR.setName("wb_ctrl_err")
    wbCtrl.BTE.setName("wb_ctrl_bte")
    wbCtrl.CTI.setName("wb_ctrl_cti")

    // User ports (dynamically created based on config)
    val userPorts = config.userPorts.map { case (portName, portConfig) =>
      portConfig.portType match {
        case UserPortType.Native =>
          val port = slave(NativePort(
            addressWidth = config.nativePortAddressWidth(portConfig.dataWidth),
            dataWidth = portConfig.dataWidth
          ).setLiteDramNames(portName))
          portName -> port
        case _ =>
          SpinalError(s"Unsupported user port type: ${portConfig.portType}")
          portName -> null
      }
    }

    // DDR physical interface
    val dram = (!sim) generate {
      config.memType match {
        case DramMemType.Sdr =>
          master(SdrDramIo(
            addressWidth = config.addressWidth,
            bankAddressWidth = config.bankAddressWidth,
            dataWidth = config.ddrDataWidth
          ).setLiteDramNames())
        case DramMemType.Ddr2 =>
          master(Ddr2Io(
            addressWidth = config.addressWidth,
            bankAddressWidth = config.bankAddressWidth,
            dataWidth = config.ddrDataWidth,
            numRanks = config.numRanks
          ).setLiteDramNames())
        case DramMemType.Ddr3 =>
          master(Ddr3Io(
            addressWidth = config.addressWidth,
            bankAddressWidth = config.bankAddressWidth,
            dataWidth = config.ddrDataWidth,
            numRanks = config.numRanks
          ).setLiteDramNames())
        case DramMemType.Ddr4 =>
          master(Ddr4Io(
            addressWidth = config.addressWidth,
            bankAddressWidth = config.bankAddressWidth,
            bankGroupWidth = 2,
            dataWidth = config.ddrDataWidth,
            numRanks = config.numRanks
          ).setLiteDramNames())
      }
    }

    val simTrace = sim generate {
      in Bool() setName("sim_trace")
    }
  }

  // Map IO names to match LiteDRAM's generated Verilog
  mapCurrentClockDomain(io.clk, io.rst)
  noIoPrefix()

  /**
   * ClockDomain for the user clock.
   *
   * This clock domain should be used for logic interfacing with LiteDram.
   * The frequency is taken from the config to match what LiteDRAM generates.
   */
  val userClockDomain = ClockDomain(
    clock = io.userClk,
    reset = io.userRst,
    config = ClockDomainConfig(
      clockEdge = RISING,
      resetKind = SYNC,
    ),
    frequency = FixedFrequency(config.userClkFreq)
  )
}

object LiteDram {
  /**
   * Create NativePort instances for all native ports in the config
   */
  def createNativePorts(config: LiteDramConfig): Map[String, NativePort] = {
    config.nativePortConfigs.map { case (portName, portConfig) =>
      portName -> NativePort(
        addressWidth = config.nativePortAddressWidth(portConfig.dataWidth),
        dataWidth = portConfig.dataWidth
      )
    }
  }

  /**
   * Create the appropriate DRAM physical interface bundle based on memory type
   */
  def createDramIo(config: LiteDramConfig): Bundle with IMasterSlave = {
    config.memType match {
      case DramMemType.Sdr => 
        SdrDramIo(
          addressWidth = config.addressWidth,
          bankAddressWidth = config.bankAddressWidth,
          dataWidth = config.ddrDataWidth
        )
      case DramMemType.Ddr2 =>
        Ddr2Io(
          addressWidth = config.addressWidth,
          bankAddressWidth = config.bankAddressWidth,
          dataWidth = config.ddrDataWidth,
          numRanks = config.numRanks
        )
      case DramMemType.Ddr3 =>
        Ddr3Io(
          addressWidth = config.addressWidth,
          bankAddressWidth = config.bankAddressWidth,
          dataWidth = config.ddrDataWidth,
          numRanks = config.numRanks
        )
      case DramMemType.Ddr4 =>
        Ddr4Io(
          addressWidth = config.addressWidth,
          bankAddressWidth = config.bankAddressWidth,
          bankGroupWidth = 2,
          dataWidth = config.ddrDataWidth,
          numRanks = config.numRanks
        )
    }
  }
}
